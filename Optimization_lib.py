import numpy as np
from numpy.linalg import solve
import pandas as pd
import matplotlib.pyplot as plt
from scipy.optimize import minimize, BFGS, LinearConstraint, NonlinearConstraint, Bounds

class Optimization_lib:
    def __init__(self, month, cluster, node, gamma, path, mu):
        self.month = month
        self.cluster = cluster
        self.node = node
        self.gamma = gamma #最適化でのmuの動く率
        self.path = path
        self.duration = np.zeros((self.cluster, self.node))
        self.mu = mu
        for i in range(cluster):
            self.duration[i] = np.array(pd.read_csv(self.path + self.month + '/ctmc/group_mean_duration_'+self.month+'_kmeans_'+str(i)+'.csv',index_col=0)).T[0]
        mu_mean = self.duration / 3600 #平均滞在時間(Hour)
        #平均滞在時間が0になってしまう(3時間で切っているから)場合は1時間とする
        self.mu_mean = np.where(mu_mean == 0, 1, mu_mean)
        #self.mu = 1 / self.mu_mean #滞在率
        self.K = np.zeros(self.cluster) #各クラスタの総和
        for i in range(self.cluster):
            self.K[i] = self.mu_mean[i].sum()
        print('K = {0}'.format(self.K))
        #推移確率行列の取り込み
        self.p = np.zeros((self.cluster, self.node, self.node))
        for i in range(self.cluster):
          self.p[i] = pd.read_csv(self.path + self.month + '/ctmc/group_transition_rate_noout_'+self.month+'_kmeans_'+str(i)+'.csv', index_col=0).values
        
        #初期分布の定常分布を求めておく(クラスタごと)
        q = np.zeros((cluster, node, node))
        pi = np.zeros((cluster, node))
        for i in range(self.cluster):
            q[i] = self.getTransitionRate(self.mu[i*self.node:(i+1)*self.node], self.p[i])
            pi[i] = self.getStationary_solve(q[i])
        #目的関数の値(初期値)
        val0 = self.getObjective(pi)
        print('初期目的関数 : {0}'.format(val0))
        
        #等式制約
        self.cons = ({'type':'eq','fun':self.getConstraint})
        #bounds
        #mu = np.array([1.685405,2.55331003,2.36392575,12.96323733,2.59387581,2.14887887,3.02985132,1.4180166,1.8818737,0.95834197,11.65162425,1.98128168,2.82833905,4.62087429,1.5865729,1.41503574,1.93538965,3.00840175,3.57346757,3.89930942,1.15042735,2.63292581,1.62233407,3.03592357,5.40727237,8.84624577,6.14325481,2.03987221,5.9925005,2.38083003,9.34930824,1.67820917,2.69912117,2.08825954,2.20846571,4.1533306,1.11291008,0.84883703,0.82654892,1.25848023,0.7024883,1.07459608,2.00085862,1.66749012,1.23068175,1.39247668,5.41633781,1.29316916,0.90834102,1.74046502,0.76442079,4.82822656,0.51678486,3.63958044,1.52692101,1.63325006,2.06600388,2.26511967,1.35479222,0.82866488,1.12609158,1.87337381,4.12909448,0.94761779,1.73413353,0.71803464,1.74435809,6.4567373,4.01672666,3.29720653,4.55379166,2.85717885,2.15739665,8.09905317,0.87544737,2.96743013,0.85930653,1.77186493,3.77371369,0.95533678,0.3861418,0.51326651,1,0.46783626,0.37232392,1.99445983])
        self.lb = self.mu * (1 - self.gamma)
        self.ub = self.mu * (1 + self.gamma)
        #print(self.lb)
        #print(self.ub)
        
    #推移率行列を作成する関数
    def getTransitionRate(self, mu, p):
        q = p.copy()
        #推移率行列を求める
        #(1)サービス率と推移確率との積をとる
        for i in range(len(q)):
            q[i] *= mu[i]
        #(2)対角要素に行和のマイナス値を入れる
        for i in range(len(q)):
            q[i][i] = np.sum(q[i]) * (-1)
        return q
        
    #推移率確率行列から定常分布を求める関数
    def getStationary_solve(self, q):#numpy.solveを使う場合
        #定常分布を求める
        q1 = q.copy()
        #(3)最終列に1を代入
        right = [0 for i in range(len(q))]
        right[-1] = 1 #最後の要素のみ1にする
        q1[:,-1] = 1 #最終列を1にする
        #(4)連立方程式を解く πP=0 => P^tπ=0
        e = np.eye(len(q)) #次元を1つ小さくする
        pi = solve(q1.T, right)
        return pi
        
    #目的関数
    def getObjective(self, pi):
      return np.var(pi)
    
    #制約条件  
    def getConstraint(self, mu):
        Ts = np.zeros(self.cluster)
        for i in range(self.cluster):
            #print(mu[i*self.node:(i+1)*self.node].shape)
            for j in mu[i*self.node:(i+1)*self.node]:
                Ts[i] += 1/j    
            #Ts[i] = [1/j for j in mu[i*self.node:(i+1)*self.node]]#平均時間に変換 ここを直す
        #print(self.K - np.sum(Ts))
        #return self.K - np.sum(Ts)
        #print(Ts)
        #print(self.K - Ts)
        return self.K - Ts
        #print(self.K.sum() - Ts.sum())
        #return self.K.sum() - Ts.sum()
      
    #目的関数 (サービス率を変更して、再度定常分布を求め、目的関数を求める)
    def getOptimize(self, mu):
        q = np.zeros((self.cluster, self.node, self.node))
        pi = np.zeros((self.cluster, self.node))
        for i in range(self.cluster):
            #(1)推移確率行列を求める
            q[i] = self.getTransitionRate(mu[node*i:node*(i+1)], self.p[i])
            #(2)定常分布を求める
            pi[i] = self.getStationary_solve(q[i])
        #(3)目的間数値を求める
        #print(self.getObjective(pi))
        return self.getObjective(pi)
      
    def executeOptimize(self):
        # 最適化
        mu = self.mu
        #mu = np.array([1.685405,2.55331003,2.36392575,12.96323733,2.59387581,2.14887887,3.02985132,1.4180166,1.8818737,0.95834197,11.65162425,1.98128168,2.82833905,4.62087429,1.5865729,1.41503574,1.93538965,3.00840175,3.57346757,3.89930942,1.15042735,2.63292581,1.62233407,3.03592357,5.40727237,8.84624577,6.14325481,2.03987221,5.9925005,2.38083003,9.34930824,1.67820917,2.69912117,2.08825954,2.20846571,4.1533306,1.11291008,0.84883703,0.82654892,1.25848023,0.7024883,1.07459608,2.00085862,1.66749012,1.23068175,1.39247668,5.41633781,1.29316916,0.90834102,1.74046502,0.76442079,4.82822656,0.51678486,3.63958044,1.52692101,1.63325006,2.06600388,2.26511967,1.35479222,0.82866488,1.12609158,1.87337381,4.12909448,0.94761779,1.73413353,0.71803464,1.74435809,6.4567373,4.01672666,3.29720653,4.55379166,2.85717885,2.15739665,8.09905317,0.87544737,2.96743013,0.85930653,1.77186493,3.77371369,0.95533678,0.3861418,0.51326651,1,0.46783626,0.37232392,1.99445983])
        res = minimize(self.getOptimize,                       # 目的関数, 
                        #self.mu[0:2].reshape(1,self.node*2),                     # 初期解,
                        mu,
                        method="trust-constr",  # 制約付き信頼領域法
                        jac="2-point",          # 勾配関数
                        hess=BFGS(),            # ヘシアンの推定方法
                        constraints=self.cons,      # 制約
                        bounds=Bounds(self.lb, self.ub),
                        options={"maxiter": 100, # 最大反復数
                                 "verbose":2})  # 最適化の過程を出力
        print('最適化結果')                         
        print(res["x"])
        #最終結果
        q = np.zeros((self.cluster, self.node, self.node))
        pi = np.zeros((self.cluster, self.node))
        Ts = np.zeros(self.cluster)
        for i in range(self.cluster):
            q[i] = self.getTransitionRate(res["x"][i*self.node:(i+1)*self.node], self.p[i])
            pi[i] = self.getStationary_solve(q[i])
            for j in res["x"][i*self.node:(i+1)*self.node]:
                Ts[i] += 1/j
        #q = getTransitionRate(transition[0], res['x'])
        #pi = getStationary_solve(q)
        val = self.getObjective(pi)
        print('定常分布pi = {0}'.format(pi))
        print('目的間数値(最終) : {0}'.format(val))
        print('クラスタ平均滞在時間(時) : {0}'.format(Ts))
        
        
if __name__ == '__main__':
    path = '/content/drive/MyDrive/研究/WiFiLog/wifidata/cluster/'
    month = '201409'
    cluster = 5
    node = 43
    gamma = 0.25 #最適化でのmuの動く率
    mu = np.array([1.685404999,2.55331005,2.363925755,12.96323807,2.593875802,2.148878885,3.029851307,1.418016604,1.881873697,0.958341967,11.65162481,1.981281683,2.828339052,4.620874356,1.586572897,1.415035742,1.935389649,3.008401774,3.573467618,3.899309382,1.150427349,2.632925828,1.622334063,3.035923537,5.40727223,8.846246051,6.143254805,2.039872199,5.992500386,2.380830052,9.34930781,1.678209166,2.699121188,2.088259538,2.208465689,4.153330668,1.112910081,0.84883703,0.826548923,1.258480222,0.702488296,1.074596085,2.000858608,1.667490129,1.230681743,1.392476682,5.416337918,1.293169155,0.908341016,1.740465023,0.764420793,4.828226663,0.516784862,3.639580496,1.526920999,1.633250071,2.066003865,2.265119662,1.354792212,0.828664877,1.126091583,1.873373794,4.129094488,0.947617792,1.734133537,0.71803464,1.744358079,6.45673747,4.016726614,3.297206501,4.55379171,2.857178858,2.157396625,8.099053366,0.875447371,2.96743011,0.859306525,1.771864946,3.773713639,0.955336783,0.3861418,0.513266512,1,0.467836257,0.372323922,1.994459829,2.169893222,1.764954357,1.892037502,14.16462094,1.874735639,1.213974016,2.048810534,1.067747227,3.112518218,0.730015632,11.28289189,2.074517627,2.520310934,4.67052614,3.454436552,1.31045755,1.607998131,1.673405386,2.954284893,7.408967681,0.713443637,2.898539971,0.873901379,2.712829622,8.532332934,8.263504653,3.645915404,3.957566497,5.122794931,2.820410794,11.37866266,1.250238186,4.430755576,1.11250732,2.319335371,4.554959711,1.147560765,1.048874642,0.555408517,0.789589122,0.50598752,0.472866473,1.887302024,2.101024264,0.734493617,1.182329015,9.380598165,0.686426681,0.951095443,1.228252802,1.023396711,2.610966057,0.786028408,7.938258133,1.211514192,1.225039709,1.993493834,1.286356205,0.791930588,1.107171708,1.391858206,1.232742392,1.876273744,0.869595222,1.458521352,1.133080895,1.634917228,2.042080166,12.43216544,1.986211679,1.361024669,2.831701315,1.660159698,11.70225165,0.977963117,1.982857758,1.003303356,1.262895026,2.872090282,0.745466118,0.613183445,0.589487473,1,0.693660714,0.520984082,1.439712064,2.398401092,1.648949311,1.733082009,11.41864047,1.485989423,1.435319604,1.700205516,0.588561558,2.324330149,0.744299512,17.45983496,2.090684223,2.534991887,3.964190044,2.119475019,1.183451728,1.733347926,1.770452323,2.522477609,6.007883785,0.72915823,2.981952656,0.764207936,2.401391597,3.618636397,11.63579226,6.17651148,4.094655999,6.433052509,2.077835381,7.780574116,1.516676027,4.200604753,1.090812021,2.298888731,5.005114977,1.037869599,1,0.569890772,0.808807009,0.501427675,0.4645461,1.62052668])
    olib = Optimization_lib(month, cluster, node, gamma, path, mu)
    olib.executeOptimize()
